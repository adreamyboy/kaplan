<?php

require_once('rest_moodle/rest_api_moodle.php');

function updateContact($contact) {
	$contact->first_name = trim($contact->first_name);
	$contact->last_name = trim($contact->last_name);
	$contact->name = trim($contact->first_name . ' ' . $contact->last_name);
	
	// Synchronize contact with Moodle
	$contact->id = ($contact->id == '') ? create_guid() : $contact->id;
	$contact->email1 = strtolower($contact->email1); // This is important because 'username' must be in LOWERCASE...
}

function updateDiscount($discount) {
	if ($discount->ratio_type_c == 'Amount') {
		$discount->rate_c = $discount->discount_ratio_c;
	} else {
		$discount->rate_c = $discount->ratio_c . '%';
	}
}

function updateLead($lead) {
	
	// auto-change the status of an existing lead, from "New" to "Assigned" when the assignee is changed.
	/*
	if ($lead->fetched_row['status'] = 'New' &&
		$lead->status == 'New' &&
		$lead->fetched_row['assigned_to'] != "" && 
		$lead->assigned_to != '' &&
		$lead->fetched_row['assigned_to'] != $lead->assigned_to)
	{
		$lead->status = 'Assigned';
	}
	*/
	
	//$GLOBALS['log']->fatal("Lead: {$lead->id} || send_email_verification_link_c: {$lead->send_email_verification_link_c} || email_verification_date_sent_c: {$lead->email_verification_date_sent_c}");
	
	// check if we need to send the "email-address" verification to the custmoer(to, later on, send the lead auto-conversion email).
	if ($lead->send_email_verification_link_c == 1 && 
		$lead->email_verification_date_sent_c == '' && 
		$lead->deleted == 0 && 
		$lead->contact_id == '')
	{
		// send email to student...
		$email_template_id = 'b5926be8-47c9-ec39-f7c1-54c85d1ab040';  // This is the ID of Email Template titled (Genesis Institute e-Learning Portal: New user account‏)
		//sendLeadEmailVerificationLinkViaEmail($lead, $email_template_id);
		$GLOBALS['log']->fatal("Lead: {$lead->id} || Sent email verification link (supposedly!)...");
		
		// update the lead's fields
		$lead->email_verification_date_sent_c = $GLOBALS['timedate']->nowDb();
			
		// reset "initiating" fields.
		$lead->send_email_verification_link_c = 0;
	}
}

function updateOpportunity($opportunity) {
	// BUG: If currency is different, the calculations will be wrong.
	
	// Calculate discounts
	if ($opportunity->auto_discount_c == 1) {
		calculateDiscounts($opportunity);
		$opportunity->auto_discount_c = 0;
	}
	
	// Update: name
	$opportunity->name = 'IN-' . sprintf('%08d', $opportunity->reference_c);
	
	// Update: amount_before & discount & amount_after & cash_flow
	$amount = 0;
	$total_before_discounts = 0;
	$total_discounts = 0;
	$collection = $opportunity->get_line_items();
	if (count($collection) > 0) {
		foreach ($collection as $item) {
			if (!$item->excluded_from_invoice_c) {
				$amount += $item->total_price_net;
				$total_before_discounts += $item->total_price;
				$total_discounts += $item->total_discount;
			}
		}
	}
	$opportunity->amount                   = $amount;
	$opportunity->total_before_discounts_c = $total_before_discounts;
	$opportunity->total_discounts_c        = $total_discounts;
	$opportunity->cash_flow_c              = $amount;
	
	// Update: payments & allocations & refunds & unpaid
	$total_payments               = 0;
	$total_installments           = 0;
	$total_promises               = 0;
	$total_creditnote_allocations = 0;
	$total_refunds                = 0;
	$collection = $opportunity->get_payments();
	if (count($collection) > 0) {
		foreach ($collection as $item) {
			switch ($item->type) {
				case 'Receipt':
					$total_payments += $item->amount;
					break;
				case 'Installment':
					$total_installments += $item->amount;
					break;
				case 'Promise':
					$total_promises += $item->amount;
					break;
				case 'Refund':
					$total_refunds += $item->amount;
					break;
				case 'Credit_Note_Allocation':
					$total_creditnote_allocations += $item->amount;
					break;
			}
		}
	}
	$opportunity->total_payments_c               = $total_payments;
	$opportunity->total_installments_c           = $total_installments;
	$opportunity->total_promises_c               = $total_promises;
	$opportunity->total_refunds_c                = $total_refunds;
	$opportunity->total_creditnote_allocations_c = $total_creditnote_allocations;
	$opportunity->total_unpaid_c = $opportunity->amount - $opportunity->total_payments_c - $opportunity->total_creditnote_allocations_c + $opportunity->total_refunds_c;
	
	// Update: sales_stage & probability
	global $timedate;
	$sales_stage_temp = $opportunity->sales_stage;
	if (count($collection) > 0 && $opportunity->total_unpaid_c == 0 && $opportunity->amount == 0 && ($total_payments + $total_installments + $total_promises + $total_creditnote_allocations - $total_refunds == 0) && $sales_stage_temp != 'Open') {
		$opportunity->sales_stage = 'Closed Lost';
		$opportunity->probability = 0;
	}
	if ($opportunity->total_unpaid_c != 0 || $opportunity->amount > 0) {
		$opportunity->sales_stage = 'Closed Won';
		$opportunity->probability = 100;
	}
	if (count($collection) == 0 && $opportunity->sales_stage == 'Closed Won') {
		$opportunity->sales_stage = 'Open';
		$opportunity->probability = 50;
	}
	
	// Update: date_closed
	if ($opportunity->sales_stage == 'Closed Won') {
		if ($opportunity->date_closed == '') {
			$opportunity->date_closed = $timedate->to_display_date($timedate->nowDbDate());
		}
	} else {
		$opportunity->date_closed = '';
	}
	
	// Update: reason_of_loss
	if ($opportunity->sales_stage != 'Closed Lost') {
		$opportunity->reason_of_loss_c = '';
	}
	
	// Update: status
	$opportunity->status_c = 'Opportunity';
	if ($opportunity->sales_stage == 'Closed Won') {
		if ($opportunity->total_unpaid_c == 0) {
			$opportunity->status_c = 'Invoice_Paid';
		} elseif ($opportunity->total_unpaid_c < 0) {
			$opportunity->status_c = 'Invoice_Overpaid';
		} else {
			$opportunity->status_c = 'Invoice_Unpaid';
		}
	}
}


function updateCreditNote($credit_note) {
	
	// Update 'totals' of credit notes
	$amount = toNumber($credit_note->amount_c);
	$amount_allocated = 0;
	$amount_refunded = 0;
	$collection = $credit_note->get_payments();
	if (count($collection) > 0) {
		foreach($collection as $item) {
			if ($item->type == 'Credit_Note_Allocation') {
				$amount_allocated += $item->amount;
			} elseif ($item->type == 'Refund') {
				$amount_refunded += $item->amount;
			}
		}
	}
	$credit_note->amount_allocated_c = $amount_allocated;
	$credit_note->amount_refunded_c = $amount_refunded;
	$credit_note->amount_unallocated_c = $amount - ($amount_allocated + $amount_refunded);
	
	// Update 'Cash Flow' of credit note.
	$credit_note->cash_flow_c = $amount * -1;
	
	// Update 'Status' of credit note.
	if ($credit_note->amount_unallocated_c == 0) {
		$credit_note->status_c = 'Allocated';
	} elseif ($credit_note->amount_unallocated_c < 0) {
		$credit_note->status_c = 'Over_Allocated';
	} else {
		$credit_note->status_c = 'Not_Allocated';
	}
}


function updateProduct($product) {
	
	// Update: 'Product Name'
	$product->name = '';
	$product_name = array();
	if ($product->gi_products_catalog_gi_products_1_name != '') {
		$product_name[] = $product->gi_products_catalog_gi_products_1_name;
	}
	if ($product->gi_terms_gi_products_1_name != '') {
		$product_name[] = $product->gi_terms_gi_products_1_name;
	}
	if ($product->gi_locations_gi_products_1_name != '') {
		$product_name[] = $product->gi_locations_gi_products_1_name;
	}
	if ($product->batch_c != '') {
		$product_name[] = $product->batch_c;
	}
	$product->name = implode(' - ', $product_name);
	
	// Update: 'Product Code'
	$product->code_c = '';
	$product_code = array();
	$catalog_id = $product->gi_products_catalog_gi_products_1gi_products_catalog_ida;
	if ($catalog_id != '') {
		$catalog = new GI_Products_Catalog();
		$catalog->retrieve($catalog_id);
		$product_code[] = $catalog->code_c;
	}        
	$term_id = $product->gi_terms_gi_products_1gi_terms_ida;
	if ($term_id != '') {
		$term = new GI_Terms();
		$term->retrieve($term_id);
		$product_code[] = $term->code;
	}
	$location_id = $product->gi_locations_gi_products_1gi_locations_ida;
	if ($location_id != '') {
		$location = new GI_Locations();
		$location->retrieve($location_id);
		$product_code[] = $location->code;
	}
	$batch = $product->batch_c;
	if ($batch != '') {
		$product_code[] = $batch;
	}
	$product->code = implode('-', $product_code);
	
	// Update Web Hidden
	switch ($product->status_c) {
		case 'Complete':
			$product->web_hidden = 1;
			break;
		case 'Cancelled':
			$product->web_hidden = 1;
			break;
		case 'Active':
			break;
	}
	
	// Update 'Date Start' & 'Date End' (if the service is NOT provisional)
	if (!$product->provisional_c) {
		global $timedate;
		$dates = array();
		$min = '';
		$max = '';
		$number_of_sessions = '';
		$collection = $product->get_sessions();
		if (count($collection) > 0) {
			foreach ($collection as $item) {
				if ( $timedate->check_matching_format($item->date_start, 'Y-m-d H:i:s') ) {
					$dates[] = $item->date_start;
				} else {
					$dates[] = $timedate->to_db($item->date_start);
				}
			}
		}
		// NOTE: array 'dates' must store values as format 2014-06-23... otherwise, min & max will not work.
		if (count($dates) > 0) {
			$min = min($dates);
			$max = max($dates);
			$number_of_sessions = count($dates);
		}
		$product->date_start_c = $min;
		$product->date_end_c = $max;
		$product->number_of_sessions_c = $number_of_sessions;
	}
}


function updatePayment($payment) {
	
	// Update: name
	$payment->name = 'PT-' . sprintf('%08d', $payment->reference_c);
	
	// Update 'Type' based on the 'Date Cleared'
	if ($payment->date_cleared != '' && in_array($payment->type, array('Installment', 'Promise'))) {
		$payment->type = 'Receipt';
	}
	
	// Update 'Mode' based on the 'Type'
	if ($payment->type == 'Installment' || $payment->type == 'Promise') {
		$payment->mode = 'Cheque';
	}
	
	// Update 'Date Cleared' based on the 'Mode'
	if ($payment->mode != 'Cheque') {
		$payment->date_cleared = $payment->date_paid;
	}
	
	// Update 'Cash Flow' field
	switch ($payment->type) {
		case 'Receipt':
			$payment->cash_flow_c = $payment->amount * -1;
			break;
		case 'Installment':
			$payment->cash_flow_c = $payment->amount * -1;
			break;
		case 'Promise':
			$payment->cash_flow_c = 0;
			break;
		case 'Refund':
			$payment->cash_flow_c = $payment->amount;
			break;
		case 'Credit_Note_Allocation':
			$payment->cash_flow_c = 0;
			break;
	}
	
	// Update 'Verified' based on the 'Type'
	if ($payment->type == 'Promise') {
		$payment->verified_c = 0;
	}
}


function updateLineItem($line_item) {

	// Update: name
	$line_item->name = 'LI-' . sprintf('%08d', $line_item->reference_c);
	
	// Auto-calculate the quantity, price, discount, and net
	$line_item->quantity = 1;
	$line_item->total_price = $line_item->quantity * toNumber($line_item->unit_price);
	if ($line_item->discount_type_c == 'Amount') {
		$line_item->total_discount = $line_item->quantity * toNumber($line_item->discount_ratio_c);
		$line_item->discount_rate = $line_item->discount_ratio_c;
	} else {
		$line_item->total_discount = $line_item->total_price * (toNumber($line_item->discount_ratio_c) / 100);
		$line_item->discount_rate = $line_item->discount_ratio_c . '%';
	}
	$line_item->total_price_net = $line_item->total_price - $line_item->total_discount;
	
	// Auto-set the ZERO-priced lineitems to 'Active' (if the lineitem is getting added now)..
	if ($line_item->total_price == 0 && 
		!isset($line_item->fetched_row['status_c']) && 
		in_array($line_item->status_c, array('Interested_Warm','Interested_Hot')))
	{
		$line_item->status_c = 'Active';
	}
	
	// Auto-set the Exclude from Invoice
	if ($line_item->status_c == 'Cancelled' || 
		$line_item->status_c == 'Interested_Warm' ||
		$line_item->status_c == 'Interested_Hot' ||
		$line_item->status_c == 'Not_Interested' ||
		toNumber($line_item->unit_price) == 0)
	{
		$line_item->excluded_from_invoice_c = true;
	} else {
		$line_item->excluded_from_invoice_c = false;		
	}
	
	// Auto-set 'Active' to 'Complete' when product is already complete.
	if ($line_item->status_c == 'Active') {
		$collection = $line_item->get_products();
		if (count($collection) > 0) {
			$product = current($collection);
		}
		if ($product->status_c == 'Complete') {
			$line_item->status_c == 'Complete';
		}
	}
	
	// Create a new follow-up task (if user selected to)
	if ($line_item->create_followup_task_c == 1) {
		$collection = $line_item->get_opportunities();
		if (count($collection) > 0) {
		
			global $timedate;
			$date_due = $timedate->asDbDate($timedate->getNow()->modify("+4 days")); // 3 days later!
			$opportunity = current($collection);
			$contact = current($opportunity->get_contacts_list());
			
			$task = new Task();
			$task->name = 'Follow-up to close';
			$task->description = 'Follow up and close if interested.';
			$task->parent_type = 'Opportunities';
			$task->parent_id = $opportunity->id;
			$task->date_due = $date_due;
			$task->priority = 'Medium';
			$task->assigned_user_id = $line_item->assigned_user_id;
			$task->contact_id = $contact->id;
			$task->save();
		}
		$line_item->create_followup_task_c = 0;
	}
}


// Use function to convert Currency (with comma) to Number
function toNumber($str) {
    return preg_replace('/([^0-9\\.])/i', '', $str);
}


function calculateDiscounts($opportunity) {
	
	if ($opportunity->auto_discount_c == 1) {
		
		$contact = current($opportunity->get_contacts_list());
		$account = new Account();
		$account->retrieve($opportunity->account_id);
		$line_items = $opportunity->get_line_items();
		$products = array();
		$catalogs = array();
		$discounts = array();
		$matrix = array();
		
		
		// Reset the discounts on all line items
		foreach ($line_items as $line_item) {
			
			$line_item_discounts = $line_item->get_discounts();
			if (count($line_item_discounts) > 0) {
				$discount = current($line_item_discounts);
				$link = 'gi_discounts_gi_line_items_1';
				if ($line_item->load_relationship($link)) {
					$line_item->$link->delete($line_item->id, $discount->id);
				}
			}

			$db = $GLOBALS['db'];
			
			$line_item->discount_type_c = 'Percentage';
			$line_item->discount_ratio_c = 0;
			$discount_id = '';
			
			updateLineItem($line_item); // This update does NOT really get saved via the Bean object, but rather just to re-calculate the values
			
			$sql = "UPDATE gi_line_items
					SET quantity = '{$line_item->quantity}', 
						total_price = '{$line_item->total_price}',
						total_discount = '{$line_item->total_discount}',
						discount_rate = '{$line_item->discount_rate}',
						total_price_net = '{$line_item->total_price_net}'
					WHERE id = '{$line_item->id}'
					";
			$result = $db->query($sql);
			
			$sql = "UPDATE gi_line_items_cstm
					SET discount_type_c = '{$line_item->discount_type_c}', 
						discount_ratio_c = '{$line_item->discount_ratio_c}',
						status_c = '{$line_item->status_c}',
						excluded_from_invoice_c = '{$line_item->excluded_from_invoice_c}'
					WHERE id_c = '{$line_item->id}'
					";
			$result = $db->query($sql);
		}

		
		// Exclude line items whose status is set to 'Cancelled' or 'Not Interested'
		foreach ($line_items as $line_item) {
			if (in_array($line_item->status_c, array('Cancelled', 'Not_Interested'))) {
				unset($line_items[$line_item->id]);
			}
		}
		
		
		// DISCONTINUED, VALID FROM, EXPIRES ON, TARGETS
		foreach ($line_items as $item) {
			$product = current($item->get_products());
			$catalog = current($product->get_catalog());
			
			foreach ($product->get_discounts() as $discount) {
				if ($discount->isDiscountApplicable($account->id, $contact->id, $product)) {
					$products[$product->id] = $product;
					$catalogs[$catalog->id] = $catalog;
					$discounts[$discount->id] = $discount;
					$matrix[] = array (
						'product_id' => $product->id,
						'product_name' => $product->name,
						'product_price' => $product->price,
						'product_date_start' => $product->date_start_c,
						'catalog_id' => $catalog->id,
						'discount_id' => $discount->id,
						'discount_name' => $discount->name,
						'is_combo' => $discount->is_combo_c,
						'lineitem_id' => $item->id,
						'ratio_type' => $discount->ratio_type_c,
						'ratio' => $discount->ratio_c,
						'rate' => $discount->rate_c,
						//'priority' => $discount->priority_c,
						//'mutually_exclusive' => $discount->mutually_exclusive_c,
					);
				}
			}
			foreach ($catalog->get_discounts() as $discount) {
				if ($discount->isDiscountApplicable($account->id, $contact->id, $product)) {
					$products[$product->id] = $product;
					$catalogs[$catalog->id] = $catalog;
					$discounts[$discount->id] = $discount;
					$matrix[] = array (
						'product_id' => $product->id,
						'product_name' => $product->name,
						'product_price' => $product->price,
						'product_date_start' => $product->date_start_c,
						'catalog_id' => $catalog->id,
						'discount_id' => $discount->id,
						'discount_name' => $discount->name,
						'is_combo' => $discount->is_combo_c,
						'lineitem_id' => $item->id,
						'ratio_type' => $discount->ratio_type_c,
						'ratio' => $discount->ratio_c,
						'rate' => $discount->rate_c,
						//'priority' => $discount->priority_c,
						//'mutually_exclusive' => $discount->mutually_exclusive_c,
					);
				}
			}
		}
		
		// COMBO
		foreach ($matrix as $key=>$m) { 
			if ($m['is_combo'] == 1) {
				foreach ($discounts[$m['discount_id']]->get_products() as $p) {
					if (!array_key_exists($p->id, $products)) {
						unset($matrix[$key]);
					}
				}
				foreach ($discounts[$m['discount_id']]->get_catalogs() as $c) {
					if (!array_key_exists($c->id, $catalogs)) {
						unset($matrix[$key]);
					}
				}
			}
		}
		
		
		// Calculate & apply the discounts
		$matrix = array_unique($matrix, SORT_REGULAR);
		
		foreach ($line_items as $item) {
			$db = $GLOBALS['db'];
			
			$item->discount_type_c = 'Percentage';
			$item->discount_ratio_c = 0;
			$discount_id = '';
			
			foreach ($matrix as $m) {
				if ($item->id == $m['lineitem_id'] && $item->discount_ratio_c < $m['ratio']) {
					
					$item->discount_ratio_c = $m['ratio'];
					$item->discount_type_c = $m['ratio_type'];
					$discount_id = $m['discount_id'];
					
					updateLineItem($item); // This update does NOT really get saved via the Bean object, but rather just to re-calculate the values
					
					$sql = "UPDATE gi_line_items
							SET quantity = '{$item->quantity}', 
								total_price = '{$item->total_price}',
								total_discount = '{$item->total_discount}',
								discount_rate = '{$item->discount_rate}',
								total_price_net = '{$item->total_price_net}'
							WHERE id = '{$item->id}'
							";
					$result = $db->query($sql);
					
					$sql = "UPDATE gi_line_items_cstm
							SET discount_type_c = '{$item->discount_type_c}', 
								discount_ratio_c = '{$item->discount_ratio_c}',
								status_c = '{$item->status_c}',
								excluded_from_invoice_c = '{$item->excluded_from_invoice_c}'
							WHERE id_c = '{$item->id}'
							";
					$result = $db->query($sql);
				}
			}
			
			//$item->save();
			$link = 'gi_discounts_gi_line_items_1';
			if ($item->load_relationship($link)) {
				$item->$link->add($discount_id);
			}
		}
		
	}
}

function getRandomString($length = 8) {
	$validCharacters = "abcdefghijklmnopqrstuxyvwzABCDEFGHIJKLMNOPQRSTUXYVWZ#@!1234567890";
	$validCharNumber = strlen($validCharacters);
	$result = "";
	for ($i = 0; $i < $length; $i++) {
		$index = mt_rand(0, $validCharNumber - 1);
		$result .= $validCharacters[$index];
	}
	return $result;
}



/*********************************************/
/*********************************************/
/******* MOODLE INTEGRATION ******************/
/*********************************************/
/*********************************************/

// This function MUST be called AFTER AND ONLY AFTER the product is saved... not before saving, and not before/after changing the relationships
function synchMoodleProduct($product) {
	deleteProductCohort($product);
	updateProductCohort($product);
	createProductCohort($product);
	$product->save();
}

// This function MUST be called AFTER AND ONLY AFTER the product is saved... not before saving, and not before/after changing the relationships
function deleteProductCohort(&$product) {
	
	if ($product->deleted == 1 || $product->has_elearning_c == 0 || $product->status_c == 'Cancelled' || $product->status_c == 'Complete') {
	
		// delete the related cohort (if any)
		if ($product->moodle_cohort_id_c != '') {
			delete_cohort($product->moodle_cohort_id_c);
		}
		
		// update product's e-learning fields
		$product->has_elearning_c = 0;
		$product->moodle_cohort_id_c = '';
		$product->date_sync_with_moodle_c = '';
	}
}

// This function MUST be called AFTER AND ONLY AFTER the product is saved... not before saving, and not before/after changing the relationships
function updateProductCohort(&$product) {
	
	// if a cohort is set...
	if ($product->has_elearning_c == 1 && $product->status_c == 'Active' && $product->deleted == 0 && $product->moodle_cohort_id_c != '') {
	
		$result = update_cohort($product->moodle_cohort_id_c, $product->name, $product->id, "");
		
		// update product's e-learning fields & handle error
		if (!isset($result->errorcode)) {
			$product->date_sync_with_moodle_c = $GLOBALS['timedate']->nowDb();
			
		} else {
		    $note = new Note();
		    $note->name = "Cohort update on Moodle failed.";
		    $note->parent_type = 'GI_Products';
		    $note->parent_id = $product->id;
		    $note->parent_name = $product->name;
		    $note->description = "Product ID: {$product->id}\n\nCohort ID: {$product->moodle_cohort_id_c}\n\n{$result->message}";
			$note->save();
			$product->moodle_cohort_id_c = '';
			$product->date_sync_with_moodle_c = '';
		}
	}
}

// This function MUST be called AFTER AND ONLY AFTER the product is saved... not before saving, and not before/after changing the relationships
function createProductCohort(&$product) {

	// if this product "has e-learning"...
	if ($product->has_elearning_c == 1 && $product->status_c == 'Active' && $product->deleted == 0 && $product->moodle_cohort_id_c == '') {
	
		// create a new cohort on Moodle with the name/id on CRM
		$result = create_cohort($product->name, $product->id, "");
		
		// update product's e-learning fields & handle error
		if (!isset($result->errorcode)) {
			$cohort = $result[0];
			$product->moodle_cohort_id_c = $cohort->id;
			$product->date_sync_with_moodle_c = $GLOBALS['timedate']->nowDb();
			
		} else {
		    $note = new Note();
		    $note->name = "Cohort creation on Moodle failed.";
		    $note->parent_type = 'GI_Products';
		    $note->parent_id = $product->id;
		    $note->parent_name = $product->name;
		    $note->description = "Product ID: {$product->id}\n\nCohort ID: {$product->moodle_cohort_id_c}\n\n{$result->message}";
			$note->save();
		}
	}
}

// This function MUST be called AFTER AND ONLY AFTER the product is saved... not before saving, and not before/after changing the relationships
function processProductLineItemsStatus(&$product, &$line_items) {
	
	foreach ($line_items as $item) {
		switch ($product->status_c) {
			case 'Complete':
				if ($item->status_c == 'Active') {
					$item->status_c = 'Complete';
				}
				break;
			case 'Cancelled':
				if ($item->status_c == 'Active' || $item->status_c == 'Complete') {
					$item->status_c = 'Cancelled';
				}
				break;
			case 'Active':
				if ($item->status_c == 'Complete') {
					$item->status_c = 'Active';
				}
				break;
		}
	}
}

// This function MUST be called AFTER AND ONLY AFTER the product is saved... not before saving, and not before/after changing the relationships
function synchMoodleLineItemMembers(&$line_items) {
	foreach ($line_items as $line_item) {
		synchMoodleLineItemMember($line_item);
	}
}

// This function MUST be called AFTER AND ONLY AFTER the product is saved... not before saving, and not before/after changing the relationships
function synchMoodleLineItemMember(&$line_item) {
	deleteLineItemMember($line_item);
	createLineItemMember($line_item);
	$line_item->save();
}

// This function MUST be called AFTER AND ONLY AFTER the product is saved... not before saving, and not before/after changing the relationships
function deleteLineItemMember(&$line_item) {

	if ($line_item->moodle_cohort_id_c != '' && $line_item->moodle_user_id_c != '') {
		
		$products = $line_item->get_products();
		$contacts = $line_item->get_contacts();
		
		if (count($products) > 0 && count($contacts) > 0) {
			$product = current($products);
			$contact = current($contacts);
			
			if ($product->deleted == 1 || 
				$product->has_elearning_c == 0 || 
				$product->status_c != 'Active' || 
				$product->moodle_cohort_id_c == '' || 
				$contact->deleted == 1 || 
				$contact->moodle_user_id_c == '' || 
				$line_item->deleted == 1 || 
				$line_item->status_c != 'Active')
			{
			
				// before deleting a cohort member, make sure that no other "Active" lineitems exist for the same contact & product.
				// start
				$found_active = false;
			
				$contact_line_items = $contact->get_line_items('Active');
				foreach ($contact_line_items as $contact_line_item) {
					if ($contact_line_item->gi_products_gi_line_items_1gi_products_ida == $product->id) {
						$found_active = true;
						break;
					}
				}
				
				if (!$found_active) {
					delete_cohort_members($product->moodle_cohort_id_c, $contact->moodle_user_id_c);
				}
				//end
				
				$line_item->moodle_user_id_c = '';
				$line_item->moodle_cohort_id_c = '';
				$line_item->date_sync_with_moodle_c = '';
			}
		}
	} else {
		$line_item->moodle_user_id_c = '';
		$line_item->moodle_cohort_id_c = '';
		$line_item->date_sync_with_moodle_c = '';
	}
}

// This function MUST be called AFTER AND ONLY AFTER the contact is saved... not before saving, and not before/after changing the relationships
function createLineItemMember(&$line_item) {

	$products = $line_item->get_products();
	$contacts = $line_item->get_contacts();
	
	if (count($products) > 0 && count($contacts) > 0) {
		$product = current($products);
		$contact = current($contacts);
		
		if ($product->deleted == 0 && 
			$product->has_elearning_c == 1 && 
			$product->status_c == 'Active' && 
			$product->moodle_cohort_id_c != '' && 
			$contact->deleted == 0 && 
			$contact->moodle_user_id_c != '' && 
			$line_item->deleted == 0 && 
			$line_item->status_c == 'Active')
		{
			
			$result = add_member_to_cohort($product->moodle_cohort_id_c, $contact->moodle_user_id_c);
			
			// update product's e-learning fields & handle error
			if (!isset($result->errorcode)) {
				$line_item->moodle_user_id_c = $contact->moodle_user_id_c;
				$line_item->moodle_cohort_id_c = $product->moodle_cohort_id_c;
				$line_item->date_sync_with_moodle_c = $GLOBALS['timedate']->nowDb();
				
			} else {
				$note = new Note();
				$note->name = "Contact assignment in Cohort on Moodle failed.";
				$note->parent_type = 'GI_Products';
				$note->parent_id = $product->id;
				$note->parent_name = $product->name;
				$note->contact_id = $contact->id;
				$note->contact_name = $contact->name;
				$note->description = "Line Item ID: {$line_item->id}\n\nContact ID: {$contact->id}\n\nProduct ID: {$product->id}\n\nCohort ID: {$product->moodle_cohort_id_c}\n\n{$result->message}";
				$note->save();
			}
		}
	}
}

// This function MUST be called AFTER AND ONLY AFTER the contact is saved... not before saving, and not before/after changing the relationships
function synchMoodleContact(&$contact) {
	deleteContactUser($contact);
	fixContactUser($contact);
	updateContactUser($contact);
	createContactUser($contact);
	sendContactLogin($contact);
	sendContactPasswordReset($contact);
	$contact->save();
}

// This function MUST be called AFTER AND ONLY AFTER the contact is saved... not before saving, and not before/after changing the relationships
function deleteContactUser(&$contact) {
	
	$GLOBALS['log']->fatal('---- 01 ----');
	// if the contact is deleted in CRM or Email is blank, delete the user in Moodle
	if ($contact->moodle_user_id_c != '' && ($contact->deleted == 1 || $contact->email1 == '')) {
		
		eddy_mdl_delete_user($contact->moodle_user_id_c);
		
		// update the contact's e-learning fields
		$contact->username_c = '';
		$contact->password_c = '';
		$contact->moodle_user_id_c = '';
		$contact->login_last_date_synch_c = '';
		$contact->login_last_date_sent_c = '';
		$GLOBALS['log']->fatal('---- 02 ----');
	}
	$GLOBALS['log']->fatal('---- 03 ----');
}

// This function MUST be called AFTER AND ONLY AFTER the contact is saved... not before saving, and not before/after changing the relationships
function fixContactUser(&$contact) {
	
	$GLOBALS['log']->fatal('---- 04 ----');
	if ($contact->moodle_user_id_c != '') {
		$user = eddy_get_mdl_user_by_id($contact->moodle_user_id_c);
		$GLOBALS['log']->fatal('---- 05 ----');
		if ($user == 0) {
			$GLOBALS['log']->fatal('---- 06 ----');
			// update the contact's e-learning fields
			$contact->username_c = '';
			$contact->password_c = '';
			$contact->moodle_user_id_c = '';
			$contact->login_last_date_synch_c = '';
			$contact->login_last_date_sent_c = '';
		}
	}
	$GLOBALS['log']->fatal('---- 07 ----');
	
	if ($contact->email1 != '' && $contact->generate_new_password_c == 1) {
		$user = eddy_get_mdl_user_by_email($contact->email1);
		$GLOBALS['log']->fatal('---- 08 ----');
		if ($user != 0) {
			//if (!isset($user->idnumber) || $user->idnumber == '') {  //// What will happen when the USER is linked to another contact?!!!
				$GLOBALS['log']->fatal('---- 09 ----');
				$contact->moodle_user_id_c = $user->id;
			//}
		}
	}
	$GLOBALS['log']->fatal('---- 10 ----');
}
		
// This function MUST be called AFTER AND ONLY AFTER the contact is saved... not before saving, and not before/after changing the relationships
function updateContactUser(&$contact) {
	
	$GLOBALS['log']->fatal('---- 11 ----');
	if ($contact->moodle_user_id_c != '' && $contact->email1 != '' && $contact->deleted == 0) {
		
		if ($contact->generate_new_password_c == 1) {
			$GLOBALS['log']->fatal('---- 12 ----');
			$contact_password = getRandomString();
		} else {
			$contact_password = $contact->password_c;
			$GLOBALS['log']->fatal('---- 13 ----');
		}
		$GLOBALS['log']->fatal('---- 14 ----');
		
		// update the username/password on Moodle with the username/password on CRM.
		$user = new stdClass();
		$user->id = $contact->moodle_user_id_c;
		$user->firstname = $contact->first_name;
		$user->lastname = $contact->last_name;
		$user->email = $contact->email1;
		$user->username = $contact->email1;
		$user->password = $contact_password;
		$user->auth = 'manual';
		$user->idnumber = $contact->id;
		//$user->city = $contact->primary_address_city;
		$user->city = 'Dubai';
		$user->country = 'AE';
		$result = eddy_mdl_update_user($user);
			
		// update product's e-learning fields & handle error
		if (!isset($result->errorcode)) {
			$user = $result[0];
			$contact->username_c = $contact->email1;
			$contact->password_c = $contact_password;
			$contact->login_last_date_synch_c = $GLOBALS['timedate']->nowDb();
			$GLOBALS['log']->fatal('---- 15 ----');
			
		} else {
			$note = new Note();
			$note->name = "User update on Moodle failed.";
			//$note->parent_type = 'GI_Products';
			//$note->parent_id = $product->id;
			//$note->parent_name = $product->name;
			$note->contact_id = $contact->id;
			$note->contact_name = $contact->name;
			$note->description = "Contact ID: {$contact->id}\n\n{$result->message}";
			$note->save();
			$GLOBALS['log']->fatal('---- 16 ----');
		}
		
		// reset "initiating" fields.
		$contact->generate_new_password_c = 0;
		$GLOBALS['log']->fatal('---- 17 ----');
	}
}

// This function MUST be called AFTER AND ONLY AFTER the contact is saved... not before saving, and not before/after changing the relationships
function createContactUser(&$contact) {
	
	$GLOBALS['log']->fatal('---- 18 ----');
	if ($contact->moodle_user_id_c == '' && $contact->generate_new_password_c == 1 && $contact->email1 != '' && $contact->deleted == 0) {
		
		$GLOBALS['log']->fatal('---- 19 ----');
		$contact_password = getRandomString();
		
		// create the username/password on Moodle with the username/password on CRM.
		$user = new stdClass();
		$user->firstname = $contact->first_name;
		$user->lastname = $contact->last_name;
		$user->email = $contact->email1;
		$user->username = $contact->email1;
		$user->password = $contact_password;
		$user->auth = 'manual';
		$user->idnumber = $contact->id;
		//$user->city = $contact->primary_address_city;
		$user->city = 'Dubai';
		$user->country = 'AE';
		$result = eddy_mdl_create_user($user);
		
		// update product's e-learning fields & handle error
		if (!isset($result->errorcode)) {
			$GLOBALS['log']->fatal('---- 20 ----');
			$user = $result[0];
			$contact->username_c = $contact->email1;
			$contact->password_c = $contact_password;
			$contact->moodle_user_id_c = $user->id;
			$contact->login_last_date_synch_c = $GLOBALS['timedate']->nowDb();
			
		} else {
			$note = new Note();
			$note->name = "User creation on Moodle failed.";
			//$note->parent_type = 'GI_Products';
			//$note->parent_id = $product->id;
			//$note->parent_name = $product->name;
			$note->contact_id = $contact->id;
			$note->contact_name = $contact->name;
			$note->description = "Contact ID: {$contact->id}\n\n{$result->message}";
			$note->save();
			$GLOBALS['log']->fatal('---- 21 ----');
		}
		
		// reset "initiating" fields.
		$contact->generate_new_password_c = 0;
		$GLOBALS['log']->fatal('---- 22 ----');
	}
}

function sendContactLogin(&$contact) {
	// if we want to send the username/password to the contact's email address
	$GLOBALS['log']->fatal('---- 23 ----');
	if ($contact->send_login_immediately_c == 1 && 
		$contact->deleted == 0 && 
		$contact->username_c != '' && 
		$contact->password_c != '' && 
		$contact->moodle_user_id_c != '')
	{
		// send email to student...
		$email_template_id = 'e983abff-de90-453e-819e-54873ced973f';  // This is the ID of Email Template titled (Genesis Institute e-Learning Portal: New user account‏)
		sendLoginViaEmail($contact, $email_template_id);
		$GLOBALS['log']->fatal('---- 24 ----');
		
		// update the contact's e-learning fields
		$contact->login_last_date_sent_c = $GLOBALS['timedate']->nowDb();
			
		// reset "initiating" fields.
		$contact->send_login_immediately_c = 0;
	}
}

// This function MUST be called AFTER AND ONLY AFTER the contact is saved... not before saving, and not before/after changing the relationships
function sendContactPasswordReset(&$contact) {

	$GLOBALS['log']->fatal('---- 25 ----');
	// if we want to send a "Password Reset" link to the contact's email address
	if ($contact->send_reset_link_immediately_c == 1 && $contact->deleted == 0) {
		
		// send email to contact...
		$email_template_id = 'b5a7ff5a-1134-316d-026d-54b659d5b0e3';  // This is the ID of Email Template titled (Genesis Institute e-Learning Portal: New user account‏)
		sendResetLinkViaEmail($contact, $email_template_id);
		$GLOBALS['log']->fatal('---- 26 ----');
		
		// reset "initiating" fields.
		$contact->send_reset_link_immediately_c = 0;
	}
}



/*****************************************/
/*****************************************/
/******* EMAIL / SMS COMMUNICATION *******/
/*****************************************/
/*****************************************/

function sendLeadEmailVerificationLinkViaEmail($lead, $templateID) {

	// Get the TO name and e-mail address for the message
	$rcpt_name = $lead->first_name . ' ' . $lead->last_name;
	$rcpt_email = $lead->email1;

	// Check if we need to send the logins immediately via email & whether the lead has an email address...
	if ($lead->send_email_verification_link_c == 1 && $rcpt_email) {

		// Send login details to lead
		require_once('modules/EmailTemplates/EmailTemplate.php');
		$emailTemp = new EmailTemplate();
		//$template_name = 'Genesis Institute e-Learning Portal: New user account‏';
		//$emailTemp->retrieve_by_string_fields(array('name'=>$template_name,'type'=>'email'));
		$emailTemp->retrieve($templateID);
		$emailTemp->disable_row_level_security = true;

		// Parse Subject & Body HTML If we used variable in subject
		$emailTemp->subject = $emailTemp->parse_template_bean($emailTemp->subject,$lead->module_dir, $lead);
		$emailTemp->body_html = $emailTemp->parse_template_bean($emailTemp->body_html,$lead->module_dir, $lead);
		
		require_once('include/SugarPHPMailer.php');
		$mail = new SugarPHPMailer();
		
		require_once ('modules/Emails/Email.php');
		$emailObj = new Email();
		
		$defaults = $emailObj->getSystemDefaultEmail();
		
		$mail->From = 'info@genesisreview.com';  // $defaults['email']; // always send it from 'info@genesisreview.com' (instead of the default 'promotions@genesisreview.com')
		$mail->FromName = $defaults['name'];
		$mail->ClearAllRecipients();
		$mail->ClearReplyTos();
		$mail->AddAddress($rcpt_email, $rcpt_name);
		$mail->Subject = from_html($emailTemp->subject);
		$mail->Body_html = from_html($emailTemp->body_html);
		$mail->Body = wordwrap($emailTemp->body_html, 900);
		$mail->IsHTML(true); // Omit or comment out this line if plain text
		$mail->prepForOutbound();
		$mail->setMailerForSystem();
		
		// Send the message, log if error occurs
		if (!$mail->Send()) {
			$GLOBALS['log']->fatal('ERROR: Sending the email address verification link has failed!');
			$params = array(
				'module' => 'Leads',
				'action' => 'DetailView', 
				'record' => $lead->id,
			);
			$url = 'index.php?' . http_build_query($params);
			SugarApplication::appendErrorMessage("FAILED: Could not send the email address verification link to Lead (<a href='{$url}'>{$lead->name} / {$rcpt_email}</a>).  Make sure that the contact has a primary email entered.");
		
		} else {
			// now create email
			$emailObj->parent_type = 'Leads';
			$emailObj->parent_id = $lead->id;
			$emailObj->to_addrs = '';
			$emailObj->type = 'archived';
			$emailObj->deleted = '0';
			$emailObj->name = $mail->Subject;
			$emailObj->description = $mail->Body;
			$emailObj->description_html = $mail->Body_html;
			$emailObj->from_addr = $mail->From;
			$emailObj->date_sent = TimeDate::getInstance()->nowDb();
			$emailObj->modified_user_id = '1';
			$emailObj->created_by = '1';
			$emailObj->status = 'sent';
			$emailObj->save();
		}
	}
}

function sendLoginViaEmail($contact, $templateID) {

	// Get the TO name and e-mail address for the message
	$rcpt_name = $contact->first_name . ' ' . $contact->last_name;
	$rcpt_email = $contact->email1;

	// Check if we need to send the logins immediately via email & whether the contact has an email address...
	if ($contact->send_login_immediately_c == 1 && $rcpt_email) {

		// Send login details to contact
		require_once('modules/EmailTemplates/EmailTemplate.php');
		$emailTemp = new EmailTemplate();
		//$template_name = 'Genesis Institute e-Learning Portal: New user account‏';
		//$emailTemp->retrieve_by_string_fields(array('name'=>$template_name,'type'=>'email'));
		$emailTemp->retrieve($templateID);
		$emailTemp->disable_row_level_security = true;

		// Parse Subject & Body HTML If we used variable in subject
		$emailTemp->subject = $emailTemp->parse_template_bean($emailTemp->subject,$contact->module_dir, $contact);
		$emailTemp->body_html = $emailTemp->parse_template_bean($emailTemp->body_html,$contact->module_dir, $contact);
		
		require_once('include/SugarPHPMailer.php');
		$mail = new SugarPHPMailer();
		
		require_once ('modules/Emails/Email.php');
		$emailObj = new Email();
		
		$defaults = $emailObj->getSystemDefaultEmail();
		
		$mail->From = 'info@genesisreview.com';  // $defaults['email']; // always send it from 'info@genesisreview.com' (instead of the default 'promotions@genesisreview.com')
		$mail->FromName = $defaults['name'];
		$mail->ClearAllRecipients();
		$mail->ClearReplyTos();
		$mail->AddAddress($rcpt_email, $rcpt_name);
		$mail->Subject = from_html($emailTemp->subject);
		$mail->Body_html = from_html($emailTemp->body_html);
		$mail->Body = wordwrap($emailTemp->body_html, 900);
		$mail->IsHTML(true); // Omit or comment out this line if plain text
		$mail->prepForOutbound();
		$mail->setMailerForSystem();
		
		// Send the message, log if error occurs
		if (!$mail->Send()) {
			$GLOBALS['log']->fatal('ERROR: Sending the e-Learning login details has failed!');
			$params = array(
				'module' => 'Contacts',
				'action' => 'DetailView', 
				'record' => $contact->id,
			);
			$url = 'index.php?' . http_build_query($params);
			SugarApplication::appendErrorMessage("FAILED: Could not send the login details to Contact (<a href='{$url}'>{$contact->name} / {$rcpt_email}</a>).  Make sure that the contact has a primary email entered.");
		
		} else {
			// now create email
			$emailObj->parent_type = 'Contacts';
			$emailObj->parent_id = $contact->id;
			$emailObj->to_addrs = '';
			$emailObj->type = 'archived';
			$emailObj->deleted = '0';
			$emailObj->name = $mail->Subject;
			$emailObj->description = $mail->Body;
			$emailObj->description_html = $mail->Body_html;
			$emailObj->from_addr = $mail->From;
			$emailObj->date_sent = TimeDate::getInstance()->nowDb();
			$emailObj->modified_user_id = '1';
			$emailObj->created_by = '1';
			$emailObj->status = 'sent';
			$emailObj->save();
		}
	}
}

function sendResetLinkViaEmail($contact, $templateID) {

	// Get the TO name and e-mail address for the message
	$rcpt_name = $contact->first_name . ' ' . $contact->last_name;
	$rcpt_email = $contact->email1;

	// Check if we need to send the logins immediately via email & whether the contact has an email address...
	if ($contact->send_reset_link_immediately_c == 1 && $rcpt_email) {

		// Send login details to contact
		require_once('modules/EmailTemplates/EmailTemplate.php');
		$emailTemp = new EmailTemplate();
		//$template_name = 'Genesis Institute e-Learning Portal: New user account‏';
		//$emailTemp->retrieve_by_string_fields(array('name'=>$template_name,'type'=>'email'));
		$emailTemp->retrieve($templateID);
		$emailTemp->disable_row_level_security = true;

		// Parse Subject & Body HTML If we used variable in subject
		$emailTemp->subject = $emailTemp->parse_template_bean($emailTemp->subject,$contact->module_dir, $contact);
		$emailTemp->body_html = $emailTemp->parse_template_bean($emailTemp->body_html,$contact->module_dir, $contact);
		
		require_once('include/SugarPHPMailer.php');
		$mail = new SugarPHPMailer();
		
		require_once ('modules/Emails/Email.php');
		$emailObj = new Email();
		
		$defaults = $emailObj->getSystemDefaultEmail();
		
		$mail->From = 'info@genesisreview.com';  // $defaults['email']; // always send it from 'info@genesisreview.com' (instead of the default 'promotions@genesisreview.com')
		$mail->FromName = $defaults['name'];
		$mail->ClearAllRecipients();
		$mail->ClearReplyTos();
		$mail->AddAddress($rcpt_email, $rcpt_name);
		$mail->Subject = from_html($emailTemp->subject);
		$mail->Body_html = from_html($emailTemp->body_html);
		$mail->Body = wordwrap($emailTemp->body_html, 900);
		$mail->IsHTML(true); // Omit or comment out this line if plain text
		$mail->prepForOutbound();
		$mail->setMailerForSystem();
		
		// Send the message, log if error occurs
		if (!$mail->Send()) {
			$GLOBALS['log']->fatal('ERROR: Sending the password reset link has failed!');
			$params = array(
				'module' => 'Contacts',
				'action' => 'DetailView', 
				'record' => $contact->id,
			);
			$url = 'index.php?' . http_build_query($params);
			SugarApplication::appendErrorMessage("FAILED: Could not send the password reset link to Contact (<a href='{$url}'>{$contact->name} / {$rcpt_email}</a>).  Make sure that the contact has a primary email entered.");
		
		} else {
			// now create email
			$emailObj->parent_type = 'Contacts';
			$emailObj->parent_id = $contact->id;
			$emailObj->to_addrs = '';
			$emailObj->type = 'archived';
			$emailObj->deleted = '0';
			$emailObj->name = $mail->Subject;
			$emailObj->description = $mail->Body;
			$emailObj->description_html = $mail->Body_html;
			$emailObj->from_addr = $mail->From;
			$emailObj->date_sent = TimeDate::getInstance()->nowDb();
			$emailObj->modified_user_id = '1';
			$emailObj->created_by = '1';
			$emailObj->status = 'sent';
			$emailObj->save();
		}
	}
}

function SendBulkSMS($sms) {

    //return;
    
    // TO-DO 01: remove duplicate mobile numbers before sending SMS.
    // TO-DO 02: let SMSGlobal send a confirmation to "entrypoint" to confirm the message status.
    // http://support.sugarcrm.com/02_Documentation/04_Sugar_Developer/Sugar_Developer_Guide_6.5/02_Application_Framework/Entry_Points/02_Creating_Custom_Entry_Points/
    // http://www.smsglobal.com/docs/HTTP.pdf
    // https://www.smsglobal.com/http-api
    
    
    if ($sms->send_immediately_c == 1) {
	    $username = 'genesis8';
	    $password = 'F119346';
	    
	    /*
	    global $timedate;
	  	if ( $timedate->check_matching_format($sms->date_scheduled_c, 'Y-m-d H:i:s') ) {
			$scheduledatetime = $sms->date_scheduled_c;
		} else {
			$scheduledatetime = $timedate->to_db($sms->date_scheduled_c);
		}
		*/
	    
	    $contacts = $sms->get_contacts();
	    
	    /********** APPROACH 1: 1 "Note" is stored per Contact **********/
	    foreach ($contacts as $contact) {
		    $content =  'action=sendsms'.
		                '&user='.rawurlencode($username).
		                '&password='.rawurlencode($password).
		                '&to='.rawurlencode($contact->phone_mobile).
		                '&from='.rawurlencode($sms->sender_id_c).
		                '&maxsplit=3'.
		                //'&scheduledatetime='.rawurlencode($scheduledatetime).
		                '&text='.rawurlencode($sms->description);
            $smsglobal_response = file_get_contents('http://www.smsglobal.com.au/http-api.php?'.$content);
            
		    //Sample Response
		    //OK: 0; Sent queued message ID: 04b4a8d4a5a02176 SMSGlobalMsgID:6613115713715266 
		    
		    /*
		    $explode_response = explode('SMSGlobalMsgID:', $smsglobal_response);
		    if(count($explode_response) == 2) { // Message Success
		        $status = 'Sent';
		    } else { //Message Failed
		        $status = 'Failed';
		    }
		    */
		    
		    $note = new Note();
		    $note->name = "SMS Message";
		    $note->parent_type = 'GI_SMS_Messages';
		    $note->parent_id = $sms->id;
		    $note->parent_name = $sms->name;
		    $note->contact_id = $contact->id;
		    $note->contact_name = $contact->name;
		    $note->description = "SMS to {$contact->phone_mobile} - {$contact->name} \n\n{$smsglobal_response} \n\n{$sms->description}";
			$note->save();
	    }
		
	    /********** APPROACH 2: All messages are stored as 1 "Note" **********/
	    /*
	    $mobiles = array();
	    
	    foreach ($contacts as $contact) {
	        $id = $contact->id;
			$mobiles[$id] = $contact->phone_mobile;
	    }
	    $mobiles_str = implode(',', $mobiles);
	    
	    $content =  'action=sendsms'.
	                '&user='.rawurlencode($username).
	                '&password='.rawurlencode($password).
	                '&to='.rawurlencode($mobiles_str).
	                '&from='.rawurlencode($sms->sender_id_c).
	                //'&scheduledatetime='.rawurlencode($scheduledatetime).
	                '&text='.rawurlencode($sms->description);
	    
	    die('http://www.smsglobal.com.au/http-api.php?'.$content);
	    $smsglobal_response = file_get_contents('http://www.smsglobal.com.au/http-api.php?'.$content);
	    
	    //Sample Response
	    //OK: 0; Sent queued message ID: 04b4a8d4a5a02176 SMSGlobalMsgID:6613115713715266 
	    
	    $note = new Note();
	    $note->name = "SMS";
	    $note->parent_name = $sms->name;
	    $note->parent_type = 'GI_SMS_Messages';
	    $note->parent_id = $sms->id;
	    $note->description = "{$smsglobal_response}\n\nMessage to be sent to:\n" . implode("\n", $mobiles);
		$note->save();
		*/
		
		$sms->send_immediately_c = 0;
		$sms->save();
	}
}

?>